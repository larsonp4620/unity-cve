package unity_cve_bridge;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

import cve.CVEClient;
import cve.CVEClientIF;
import com.google.flatbuffers.*;
import unity_cve_fbuffer_classes.*;

public class Bridge_Unity_Server{
	String destinationAddress;
	InetAddress destinationIPAddress;
	Bridge_Controller controller;
	DatagramSocket sendSocket;
	DatagramSocket listenSocket;
	Unity_Listener listener;
	int destPort = 11001;
	int listenPort = 11000;

	public Bridge_Unity_Server(String destinationAddress, Bridge_Controller controller) {
		this.controller = controller;
		this.destinationAddress = destinationAddress;
		try {
			this.destinationIPAddress = InetAddress.getByName(this.destinationAddress);
		} catch (Exception e) {
			System.err.println(e.getMessage());
			System.err.println("Error resolving unity client address.");
		}
		try {
			this.sendSocket = new DatagramSocket();
			this.listenSocket = new DatagramSocket(listenPort);
		} catch (Exception e) {
			System.err.println(e.getMessage());
			System.err.println("Error opening sockets.");
		}
		try {
			listenProcessPackets();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.err.println("Error listening for packets");
		}
	}


	
	/**
	 * Waits for datagram packets and processes them.
	 *
	 * @throws IOException
	 */
	public void listenProcessPackets() throws IOException {

		this.listener = new Unity_Listener(this.listenSocket , this);
		this.listener.start();
	}
	
	
	

	public void close() {
		this.sendSocket.close();

	}

	// Deprecated
	public void sendMessage(String message) {
		try {

			// TODO: Use one socket for all communication
			DatagramSocket clientSocket = new DatagramSocket();

			InetAddress IPAddress = InetAddress.getByName("127.0.0.1");
			byte[] sendData = new byte[1024];
			sendData = message.getBytes();
			DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, 11001);
			clientSocket.send(sendPacket);
			System.out.println("Message Sent");
			clientSocket.close();

		} catch (Exception e) {
			System.out.println("Exception Occurred in sendMessage");
		}
	}

	private void sendByteArray(byte[] byteA) {
			DatagramPacket packet = new DatagramPacket(byteA, byteA.length, this.destinationIPAddress, this.destPort);
			sendPacket(packet);
	}
	

	private synchronized void sendPacket(DatagramPacket packet) {

		try {
			this.sendSocket.send(packet);
		} catch (Exception e) {
			System.out.println("Exception Occurred in sendByteBuffer");
		}
	}


	public void sendFBufferLocation(float x, float y, float z, String channel) {

		FlatBufferBuilder builder = new FlatBufferBuilder(0);

		int loc = Location.createLocation(builder, x, y, z);
		int channelInt = builder.createString(channel);

		Message.startMessage(builder);
		Message.addMessageDataType(builder, Data.Location);
		Message.addMessageData(builder, loc);
		Message.addChannel(builder, channelInt);

		int message = Message.endMessage(builder);
		builder.finish(message);
		byte[] byteA = builder.sizedByteArray();
		sendByteArray(byteA);
	}

	// TODO:Finish
	public void sendFBufferPosition(float x, float y, float z, float roll, float pitch, float yaw, String channel) {

		FlatBufferBuilder builder = new FlatBufferBuilder(0);

		int pos = Position.createPosition(builder, x, y, z, roll, pitch, yaw);
		int channelInt = builder.createString(channel);

		Message.startMessage(builder);
		Message.addMessageDataType(builder, Data.Position);
		Message.addMessageData(builder, pos);
		Message.addChannel(builder, channelInt);

		int message = Message.endMessage(builder);
		builder.finish(message);
		byte[] byteA = builder.sizedByteArray();
		sendByteArray(byteA);
	}

	// TODO:Finish

	public void sendFBufferOrientation(float roll, float pitch, float yaw, String channel) {
		FlatBufferBuilder builder = new FlatBufferBuilder(0);

		int ori = Orientation.createOrientation(builder, roll, pitch, yaw);
		int channelInt = builder.createString(channel);

		Message.startMessage(builder);
		Message.addMessageDataType(builder, Data.Orientation);
		Message.addMessageData(builder, ori);
		Message.addChannel(builder, channelInt);

		int message = Message.endMessage(builder);
		builder.finish(message);
		byte[] byteA = builder.sizedByteArray();
		sendByteArray(byteA);
	}

	public void sendFBufferExtraParam(String name, float value, String channel) {
		FlatBufferBuilder builder = new FlatBufferBuilder(0);

		int channelInt = builder.createString(channel);

		int nameInt = builder.createString(name);
		int ext = ExtraParam.createExtraParam(builder, nameInt, value);

		Message.startMessage(builder);
		Message.addMessageDataType(builder, Data.ExtraParam);
		Message.addMessageData(builder, ext);
		Message.addChannel(builder, channelInt);

		int message = Message.endMessage(builder);
		builder.finish(message);
		byte[] byteA = builder.sizedByteArray();
		sendByteArray(byteA);
	}

	public void receiveFBuffer(byte[] received){
		//Unparse
		System.out.println("Unity_Listener passed off buffer");
		
        Message message = Message.getRootAsMessage(ByteBuffer.wrap(received));

        byte messageType = message.messageDataType();

        switch (messageType)
        {
            case Data.NONE:
                //empty message
                break;
            case Data.Position:
                Position position = (Position) message.messageData(new Position());
               
                this.controller.handleUnityPosition(
                		position.x(), position.y(), position.z(), 
                		position.roll(), position.pitch(), position.yaw(), 
                		message.channel());
                break;

            case Data.Location:
            	Location location = (Location) message.messageData(new Location());
                
                this.controller.handleUnityLocation(
                		location.x(), location.y(), location.z(),  
                		message.channel());
                break;

            case Data.Orientation:
            	Orientation orientation = (Orientation) message.messageData(new Orientation());
                
                this.controller.handleUnityOrientation(
                		orientation.roll(), orientation.pitch(), orientation.yaw(), 
                		message.channel());

                break;

            case Data.ExtraParam:
            	ExtraParam extraParam = (ExtraParam) message.messageData(new ExtraParam());
                
                this.controller.handleUnityExtraParam(
                		extraParam.name(),extraParam.value(),
                		message.channel());
                break;

            default:
                //Won't happen
                break;
        }
	}
	
	private class Unity_Listener extends Thread {
		private DatagramSocket listenSocket;
		private Bridge_Unity_Server bridge_unity_server;
		private final int MAX_BUFFER_SIZE = 1024;
		
		public Unity_Listener( DatagramSocket listenSocket, Bridge_Unity_Server bridge_unity_server){
			this.listenSocket = listenSocket;
			this.bridge_unity_server = bridge_unity_server;
		}
		
		@Override
		public void run() {
			byte[] receiveData = new byte[this.MAX_BUFFER_SIZE];
			System.out.println("Unity_Listener is waiting...");
			try {
			while (true) {
				DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
				listenSocket.receive(receivePacket);
				
				bridge_unity_server.receiveFBuffer(receivePacket.getData());
				
//				String sentence = new String(receivePacket.getData());
//				System.out.println("Thread RECEIVED: " + sentence);
			}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				System.err.println("Error receiving packet in Unity_Listener class");
				System.err.println("Unity_Listener Breaking Loop");
			}

		}
	}

}

package unity_cve_bridge;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

import cve.CVEClient;
import cve.CVEClientIF;
import com.google.flatbuffers.*;
import unity_cve_fbuffer_classes.*;

public class Bridge_Unity_Server {
	String destinationAddress;
	InetAddress destinationIPAddress;
	Bridge_Controller controller;
	DatagramSocket sendSocket;
	DatagramSocket listenSocket;
	Unity_Listener listener;
	int destPort = 11001;
	int listenPort = 11000;

	/**
	 * Class that communicates with Unity. Sends messages encoded as flatbuffers
	 * to the IP address provided. Listens for messages on an open socket and
	 * parses them before sending the data to the parent Bridge_Controller
	 * object.
	 * 
	 * @param destinationAddress
	 *            IP address of the target Unity game.
	 * @param controller
	 *            Bridge_Controller that will pass messages to the CVE
	 *            component.
	 */
	public Bridge_Unity_Server(String destinationAddress, Bridge_Controller controller) {
		this.controller = controller;
		this.destinationAddress = destinationAddress;

		try {
			this.destinationIPAddress = InetAddress.getByName(this.destinationAddress);
		} catch (Exception e) {
			System.err.println(e.getMessage());
			System.err.println("Error resolving unity client address.");
		}

		try {
			this.sendSocket = new DatagramSocket();
			this.listenSocket = new DatagramSocket(listenPort);
		} catch (Exception e) {
			System.err.println(e.getMessage());
			System.err.println("Error opening sockets.");
		}

		try {
			listenProcessPackets();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.err.println("Error listening for packets");
		}
	}

	/**
	 * Waits for datagram packets and processes them.
	 *
	 * @throws IOException
	 */
	public void listenProcessPackets() throws IOException {

		this.listener = new Unity_Listener(this.listenSocket, this);
		this.listener.start();
	}

	/**
	 * Method that should be called on close.
	 */
	public void close() {
		this.sendSocket.close();

	}

	/**
	 * Method to send a byte array to the stored IP address. This method
	 * constructs a packet and then calls the sendPacket method.
	 * 
	 * @param byteA
	 *            byte array to send.
	 */
	private void sendByteArray(byte[] byteA) {
		DatagramPacket packet = new DatagramPacket(byteA, byteA.length, this.destinationIPAddress, this.destPort);
		sendPacket(packet);
	}

	/**
	 * Synchronized method to send a packet to the stored IP address.
	 * 
	 * 
	 * @param packet
	 *            packet to send.
	 */
	private synchronized void sendPacket(DatagramPacket packet) {

		try {
			this.sendSocket.send(packet);
		} catch (Exception e) {
			System.out.println("Exception Occurred in sendByteBuffer");
		}
	}

	/**
	 * Method that encodes a location message as a flatbuffer and then send it
	 * to the destination IP address.
	 * 
	 * 
	 * 
	 * @param x
	 * @param y
	 * @param z
	 * @param channel
	 */
	public void sendFBufferLocation(float x, float y, float z, String channel) {

		FlatBufferBuilder builder = new FlatBufferBuilder(0);

		int loc = Location.createLocation(builder, x, y, z);
		int channelInt = builder.createString(channel);

		Message.startMessage(builder);
		Message.addMessageDataType(builder, Data.Location);
		Message.addMessageData(builder, loc);
		Message.addChannel(builder, channelInt);

		int message = Message.endMessage(builder);
		builder.finish(message);
		byte[] byteA = builder.sizedByteArray();
		sendByteArray(byteA);
	}

	/**
	 * Method that encodes a Position message as a flatbuffer and then send it
	 * to the destination IP address.
	 * 
	 * 
	 * @param x
	 * @param y
	 * @param z
	 * @param roll
	 * @param pitch
	 * @param yaw
	 * @param channel
	 */
	public void sendFBufferPosition(float x, float y, float z, float roll, float pitch, float yaw, String channel) {

		FlatBufferBuilder builder = new FlatBufferBuilder(0);

		int pos = Position.createPosition(builder, x, y, z, roll, pitch, yaw);
		int channelInt = builder.createString(channel);

		Message.startMessage(builder);
		Message.addMessageDataType(builder, Data.Position);
		Message.addMessageData(builder, pos);
		Message.addChannel(builder, channelInt);

		int message = Message.endMessage(builder);
		builder.finish(message);
		byte[] byteA = builder.sizedByteArray();
		sendByteArray(byteA);
	}

	/**
	 * Method that encodes a Orientation message as a flatbuffer and then send
	 * it to the destination IP address.
	 * 
	 * 
	 * @param roll
	 * @param pitch
	 * @param yaw
	 * @param channel
	 */
	public void sendFBufferOrientation(float roll, float pitch, float yaw, String channel) {
		FlatBufferBuilder builder = new FlatBufferBuilder(0);

		int ori = Orientation.createOrientation(builder, roll, pitch, yaw);
		int channelInt = builder.createString(channel);

		Message.startMessage(builder);
		Message.addMessageDataType(builder, Data.Orientation);
		Message.addMessageData(builder, ori);
		Message.addChannel(builder, channelInt);

		int message = Message.endMessage(builder);
		builder.finish(message);
		byte[] byteA = builder.sizedByteArray();
		sendByteArray(byteA);
	}

	/**
	 * Method that encodes a Extra Parameter message as a flatbuffer and then
	 * send it to the destination IP address.
	 * 
	 * @param name
	 * @param value
	 * @param channel
	 */
	public void sendFBufferExtraParam(String name, float value, String channel) {
		FlatBufferBuilder builder = new FlatBufferBuilder(0);

		int channelInt = builder.createString(channel);

		int nameInt = builder.createString(name);
		int ext = ExtraParam.createExtraParam(builder, nameInt, value);

		Message.startMessage(builder);
		Message.addMessageDataType(builder, Data.ExtraParam);
		Message.addMessageData(builder, ext);
		Message.addChannel(builder, channelInt);

		int message = Message.endMessage(builder);
		builder.finish(message);
		byte[] byteA = builder.sizedByteArray();
		sendByteArray(byteA);
	}

	/**
	 * Method that handles data recieved. Data is parsed as a flatbuffer, then
	 * extracted into a message type and parameters. The appropriate message is
	 * called in the Bridge_Controller to pass the messate though to the CVE
	 * server.
	 * 
	 * @param received
	 *            byte array that was recieved.
	 */
	public void receiveFBuffer(byte[] received) {

		Message message = Message.getRootAsMessage(ByteBuffer.wrap(received));

		byte messageType = message.messageDataType();

		switch (messageType) {
		case Data.NONE:
			// empty message
			break;
		case Data.Position:
			Position position = (Position) message.messageData(new Position());

			this.controller.handleUnityPosition(position.x(), position.y(), position.z(), position.roll(),
					position.pitch(), position.yaw(), message.channel());
			break;

		case Data.Location:
			Location location = (Location) message.messageData(new Location());

			this.controller.handleUnityLocation(location.x(), location.y(), location.z(), message.channel());
			break;

		case Data.Orientation:
			Orientation orientation = (Orientation) message.messageData(new Orientation());

			this.controller.handleUnityOrientation(orientation.roll(), orientation.pitch(), orientation.yaw(),
					message.channel());

			break;

		case Data.ExtraParam:
			ExtraParam extraParam = (ExtraParam) message.messageData(new ExtraParam());

			this.controller.handleUnityExtraParam(extraParam.name(), extraParam.value(), message.channel());
			break;

		default:
			// Won't happen
			break;
		}
	}

	/**
	 * Thread Class used to listen for messages from the unity server. When
	 * messages are received the appropriate method on the Bridge_Unity_Server
	 * is called.
	 * 
	 * 
	 * @author peterlarson
	 *
	 */
	private class Unity_Listener extends Thread {
		private DatagramSocket listenSocket;
		private Bridge_Unity_Server bridge_unity_server;
		private final int MAX_BUFFER_SIZE = 1024;

		public Unity_Listener(DatagramSocket listenSocket, Bridge_Unity_Server bridge_unity_server) {
			this.listenSocket = listenSocket;
			this.bridge_unity_server = bridge_unity_server;
		}

		@Override
		public void run() {
			byte[] receiveData = new byte[this.MAX_BUFFER_SIZE];
			System.out.println("Unity_Listener is waiting...");
			try {
				while (true) {
					DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
					listenSocket.receive(receivePacket);

					bridge_unity_server.receiveFBuffer(receivePacket.getData());

				}
			} catch (IOException e) {

				e.printStackTrace();
				System.err.println("Error receiving packet in Unity_Listener class");
				System.err.println("Unity_Listener Breaking Loop");
			}

		}
	}

}
